package sitter

//#include <stdint.h>
//#include "bindings.h"
import "C"
import (
	"log"
	"sync"
)

var parserMap sync.Map

func registerParser(p *Parser) {
	parserMap.Store(p.c, p)
}

func unregisterParser(p *Parser) {
	parserMap.Delete(p.c)
}

func getGoParser(c *C.TSParser) (*Parser, bool) {
	obj, ok := parserMap.Load(c)
	if ok {
		return obj.(*Parser), ok
	}
	return nil, ok
}

// Token is a lexical token generated by the tree-sitter parser
type Token struct {
	Symbol     int
	SymbolName string
	Start      int
	End        int
	Lit        string
}

//export cgoLexedToken
func cgoLexedToken(parser *C.TSParser, symbol C.uint16_t, symbolName *C.char, start, end C.uint32_t) {
	p, ok := getGoParser(parser)
	if !ok {
		log.Println("cgo callback called, no parser found!")
		return
	}
	p.addToken(int(symbol), C.GoString(symbolName), int(start), int(end))
}

func (p *Parser) addToken(symbol int, symbolName string, start, end int) {
	p.tm.Lock()
	defer p.tm.Unlock()
	if len(p.tokens) > 0 {
		last := p.tokens[len(p.tokens)-1]
		if last.Start == start && last.End == end && last.Symbol == symbol {
			return
		}
	}
	p.tokens = append(p.tokens, Token{
		Symbol:     symbol,
		SymbolName: symbolName,
		Start:      start,
		End:        end,
		Lit:        string(p.contents[start:end]),
	})
}

// Tokens returns lexical tokens from the parse
func (p *Parser) Tokens() []Token {
	p.tm.Lock()
	defer p.tm.Unlock()
	return p.tokens
}
